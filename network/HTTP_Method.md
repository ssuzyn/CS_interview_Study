### 먼저, REST란?

Representational State Transfer의 약자이며, 다음과 같이 구성되어 있다.

- 자원(Resource): URI
- 행위(Verb): HTTP Method
- 표현(Representations)

즉 REST는 URI를 통해 자원을 표시하고, HTTP Method를 이용하여 해당 자원의 행위를 규정하여그 결과를 받는 것을 말한다.

- **HTTP Method의 정의**
    
    HTTP 프로토콜은 TCP와 UDP 프로토콜을 기반으로 하여 웹에서 사용하는 프로토콜로서 클라이언트와 서버 사이에 이루어지는 요청(Request)과 응답(Response) 데이터를 전송하는 방식을 말한다. HTTP Method는 말 그대로 서버에 요청을 보내는 방법이다.
    
- **HTTP Method의 종류**
    
    HTTP 명세서에 따르면 HTTP Method에는 8가지의 명령이 있다. OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT가 있다. 각각의 사용은 아래와 같다.
    
    | 종류 | 기능 |
    | --- | --- |
    | OPTIONS | 요청한 URL에 어떠한 메소드 요청이 가능한지 묻는다. |
    | GET | URL에 해당하는 정보의 전송 요청을 보낸다. (데이터 조회) |
    | POST | 서버가 처리할 수 있는 자료를 보낸다. GET으로 보낼 수 없는 자료들에 대해 전송할 때 사용한다. (요청 데이터 처리(보통 데이터 등록 사용)) |
    | PUT | 자료를 전송하여 해당 URL에 자료를 저장한다. (데이터 변경 (해당 데이터가 없으면 생성)) |
    | PATCH | 일부 데이터만 변경 |
    | DELETE | 해당 URL의 자원, 정보를 삭제한다. (데이터 삭제) |
    | HEAD | URL에 해당하는 정보의 전송을 요청하지만, GET과는 다르게 정보의 Meta 정보만을 요청한다. |
    | TRACE | 이전까지 요청한 정보들의 목록을 요청한다. |
    | CONNECT | 프록시가 사용하고, 연결을 요청한다 |
    
    GET과 DELETE는 비교적 그 행위가 명확하지만, POST와 PUT을 구분하기 위해서는 멱등성의 개념을 알아야 한다.
    
    - **멱등성(Idempotence)이란?**
        
        멱등성이란 여러번 수행해도 결과가 같음을 의미한다.
        
        HTTP 메소드를 예를 들자면, GET, PUT, DELETE는 같은 경로로 여러 번 호출해도 결과가 같다.
        
        그러나 POST는 매 호출마다 새로운 데이터가 추가된다. 따라서, POST 연산은 결과가 Idempotent하지 않지만, PUT은 반복 수행해도 그 결과가 Idempotent 하다.
        
    
    8가지 중 중요한 4가지 명령에 대해서 더 자세히 알아보겠다.
    
    ### 1. GET
    
    ### 정의
    
    GET 메소드는 주로 데이터를 읽거나(Read) 검색(Retrieve)할 때에 사용되는 메소드이다. 
    
    **GET**은 보통 리소스를 조회할 때 사용하며, 서버에 전달하고 싶은 데이터는 query를 통해서 전달한다. 메시지 바디를 사용해서 데이터를 전달할 수는 있지만, 지원하지 않는 곳이 많아서 권장하지 않는다.
    
    만약에 GET요청이 성공적으로 이루어진다면 XML이나 JSON과 함께 200 (Ok) HTTP 응답을 반환한다. 에러가 발생하면 주로 404 (Not found) 에러나 400 (Bad request) 에러가 발생한다.
    
    - HTTP 명세에 의하면 GET 요청은 오로지 데이터를 읽을 때만 사용되고 수정할 때는 사용하지 않는다.
    - GET 요청은 idempotent 하다. 즉, 같은 요청을 여러 번 하더라도 변함없이 항상 같은 응답을 받을 수 있다.
    - GET 요청은 데이터를 변경하는 연산에 사용하면 안된다.
        - 왜?
            
            GET 요청은 서버에서 데이터를 가져오는 용도로 설계되어 있습니다. 따라서 GET 요청을 사용하여 데이터를 변경하는 연산을 수행하면, 의도치 않은 결과가 발생할 수 있습니다.
            
            예를 들어, GET 요청을 사용하여 비밀번호를 변경하거나, 결제를 수행하는 등의 작업을 수행하면, 이러한 요청이 브라우저의 캐시나 로그 파일에 저장될 수 있습니다. 또한, 이러한 요청이 중간자 공격과 같은 보안 위협을 일으킬 수도 있습니다.
            
            따라서, 데이터를 변경하는 연산은 보안을 강화하기 위해 POST, PUT, DELETE와 같은 HTTP 메서드를 사용하는 것이 좋습니다. 이러한 메서드는 데이터를 보호하고, 요청에 대한 응답을 캐시하지 않으며, 중간자 공격과 같은 보안 위협으로부터 보호할 수 있도록 설계되어 있습니다.
            
    
    ### 예시
    
    ```
    GET /user/1
    ```
    
    데이터를 조회하는 것이기 때문에 요청시에 Body 값과 Content-Type 가 비워져있다. 조회할 데이터에 대한 정보는 URL을 통해서 파라메터를 받고 있는 모습을 볼 수 있다.
    
    데이터 조회에 성공한다면 Body 값에 데이터 값을 저장하여 성공 응답을 보낸다.
    
    GET은 캐싱이 가능하여 같은 데이터를 한번 더 조회할 경우에 저장한 값을 사용하여 조회 속도가 빨라진다.
    
    ### 2. POST
    
    ### 정의
    
    POST 메소드는 주로 새로운 리소스를 생성(create)할 때 사용된다. 
    
    **POST**는 데이터 요청을 처리하고, 메시지 바디를 통해 서버로 데이터를 전달한다. 주로 신규 리소스를 등록하거나 프로세스 처리에 사용된다.
    
    조금 더 구체적으로 POST는 하위 리소스(부모 리소스의 하위 리소스)들을 생성하는데 사용된다. 성공적으로 creation을 완료하면 201 (Created) HTTP 응답을 반환한다.
    
    - POST 요청은 idempotent 하지 않다. 즉, 같은 POST 요청을 반복해서 했을 때 항상 같은 결과물이 나오는 것을 보장하지 않는다
    - 두 개의 같은 POST 요청을 보내면 같은 정보를 담은 두 개의 다른 resource를 반환할 가능성이 높다.
    
    ### 예시
    
    ```
    POST /user
    body : {date : "example"}
    Content-Type : "application/json"
    
    ```
    
    데이터를 생성하는 것이기 때문에 요청시에 Body 값과 Content-Type 값을 작성해야한다. 해당 예시는 JSON을 통해서 작성된 예시이다.
    
    URL을 통해서 데이터를 받지 않고, Body 값을 통해서 받는다.
    
    데이터 조회에 성공한다면 Body 값에 저장한 데이터 값을 저장하여 성공 응답을 보낸다.
    
    ### 3. PUT
    
    ### 정의
    
    PUT는 리소스를 생성 / 업데이트하기 위해 서버로 데이터를 보내는 데 사용됩니다.
    
    **PUT**은 리소스가 있으면 대체하고 리소스가 없으면 생성한다. 쉽게 말해 데이터를 덮어쓴다.
    
    - PUT 요청은 idempotent 합니다. 즉, 동일한 PUT 요청을 여러 번 호출하면 항상 동일한 결과가 생성됩니다.
    - PUT 요청이 성공적으로 이루어진다면 200 (Ok) 또는 204 HTTP 응답을 반환한다.
    - PUT 요청이 새로운 리소스를 생성하거나, 요청한 리소스가 존재하지 않는 경우에는 HTTP 201 Created 또는 HTTP 404 Not Found와 같은 다른 응답 코드가 반환될 수도 있다.
    
    ### 예시
    
    ```
    PUT /user/1
    body : {date : "update example"}
    Content-Type : "application/json"
    
    ```
    
    데이터를 수정하는 것이기 때문에 요청시에 Body 값과 Content-Type 값을 작성해야한다. 해당 예시는 JSON을 통해서 작성된 예시이다.
    
    URL을 통해서 어떠한 데이터를 수정할지 파라메터를 받는다. 그리고 수정할 데이터 값을 Body 값을 통해서 받는다.
    
    데이터 조회에 성공한다면 Body 값에 저장한 데이터 값을 저장하여 성공 응답을 보낸다.
    
    ### 4. DELETE
    
    ### 정의
    
    DELETE 메서드는 지정된 리소스를 삭제합니다.
    
    - DELETE 요청이 성공적으로 이루어진다면 200 (Ok) 또는 204 HTTP 응답을 반환한다.
    - DELETE 요청이 삭제된 리소스를 반환해야 하는 경우에는 HTTP 200 OK와 함께 삭제된 리소스를 포함한 응답 본문을 반환할 수도 있습니다. 또한, 삭제된 리소스가 존재하지 않는 경우에는 HTTP 404 Not Found와 같은 다른 응답 코드가 반환될 수 있습니다.
    
    ### 예시
    
    ```
    DELETE /user/1
    ```
    
    데이터를 삭제하는 것이기 때문에 요청시에 Body 값과 Content-Type 값이 비워져있다.
    
    URL을 통해서 어떠한 데이터를 삭제할지 파라메터를 받는다.
    
    데이터 삭제에 성공한다면 Body 값 없이 성공 응답만 보내게 된다.
    

### HTTP 상태코드

http 상태 코드는 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능이다.보통 100번대에서 500번대를 사용하는데 크게 다음과 같이 나눌 수 있다.🧐 200, 400, 500번대의 상태코드만 사용을 해보아서, 새삼 놀랐다.

1xx (Informational): 요청이 수신되어 처리중2xx (Successful): 요청 정상 처리3xx (Redirection): 요청을 완료하려면 추가 행동이 필요4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함

### HTTP 상태코드 종류와 의미

### 1xx

먼저 100 번대는 요청이 수신되어 처리중이라는 뜻인데 거의 사용하지 않는다고 한다.

### 2xx

다음으로, 200번대는 성공의 의미를 뜻하는데 더 자세하게는 다음과 같다.

```
200 OK : 요청 성공
201 Created : 요청 성공해서 새로운 리소스가 생성됨
202 Accepted : 요청이 접수되었으나 처리가 완료되지 않았음
204 No Content : 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음
```

### 3xx

300 번대는 리다이렉션인데 이는 location 헤더가 있으면 location 위치로 자동 이동하는 것을 리다이렉트라고 한다.

```
301 Moved Permanently : 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음
302 Found : 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음
303 See Other : 리다이렉트시 요청 메서드가 GET으로 변경
304 Not Modified : 캐시를 목적으로 사용
307 Temporary Redirect : 리다이렉트시 요청 메서드와 본문 유지(요청 메서드를 변경하면 안된다.)
308 Permanent Redirect : 리다이렉트시 요청 메서드와 본문 유지(처음 POST를 보내면 리다이렉트도 POST 유지)
```

### 4xx

400번대는 클라이언트 측에서 오류가 발생했다고 알려주는 것이다. 자세한 사항은 다음과 같다.

```
400 Bad Request : 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음
401 Unauthorized : 클라이언트가 해당 리소스에 대한 인증이 필요함
403 Forbidden : 서버가 요청을 이해했지만 승인을 거부함
404 Not Found : 요청 리소스를 찾을 수 없음
```

### 5xx

500번대는 서버 측에서 오류가 발생했다고 알려주는 것이다. 자세한 사항은 다음과 같다.

```
500 Internal Server Error : 서버 문제로 오류 발생, 애매하면 500 오류
503 Service Unavailable : 서비스 이용 불가
```

---

### 질문1. **HTTP Method의 종류에 대해서 설명해주세요.**

**질문 답변**

HTTP 명세서에 따르면 HTTP Method에는 8가지의 명령이 있다. OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT가 있다. 각각의 사용은 아래와 같다.

OPTIONS

- 요청한 URL에 어떠한 메소드 요청이 가능한지 묻는다.

GET

- URL에 해당하는 정보의 전송 요청을 보낸다.

HEAD

- URL에 해당하는 정보의 전송을 요청하지만, GET과는 다르게 정보의 Meta 정보만을 요청한다.

POST

- 서버가 처리할 수 있는 자료를 보낸다. GET으로 보낼 수 없는 자료들에 대해 전송할 때 사용한다.

PUT

- 자료를 전송하여 해당 URL에 자료를 저장한다.

DELETE

- 해당 URL의 자원, 정보를 삭제한다.

TRACE

- 이전까지 요청한 정보들의 목록을 요청한다.

CONNECT

- 프록시가 사용하고, 연결을 요청한다.

---

### **GET**

네이버에 get이라는 단어를 검색해보면 위와 같이 받다, 얻다, 구하다라는 뜻을 가진 단어인데,

말 그대로 Get은 우리가 필요한 정보를 얻기 위해 도서관에서 책을 빌려 가져오는(GET)상황과 유사하게 GET은 **어떠한 정보를 가져와서 조회하기 위해 사용되는 방식**입니다.

### **[ GET 방식의 특징 ]**

- URL에 변수(데이터)를 포함시켜 요청한다.
- 데이터를 Header(헤더)에 포함하여 전송한다.
- URL에 데이터가 노출되어 보안에 취약하다.
- 길이 제한이 있다. (브라우저마다 제한이 다름)
- 캐싱할 수 있다.

GET 방식은 간단한 데이터를 URL에 넣도록 설계된 방식으로 데이터를 보내는 양에 한계가 있습니다.

HTTP 자체는 GET 방식의 URL 길이에 제약을 두고 있지 않지만, 브라우저에서 최대 길이를 제한하고 있으며 URL형식에 맞지 않는 파라미터 이름이나 값은 인코딩되어 전달해야 합니다.(만약 보내는 길이가 너무 긴 경우 초과 데이터는 절단됩니다.) 특별히 전송하는 데이터가 없으므로 GET 방식에서 바디는 보통 빈 상태로 전송됩니다.

GET방식을 사용해서 데이터를 노출시키는 경우는 개인정보가 포함되지 않는 상황에서 캐싱을 하여 속도를 높이거나 즐겨찾기를 편리하기 위해 사용되는 경우가 많습니다.

### POST

POST라는 단어는 부치다, 제출하다 라는 뜻을 가지고 있습니다.

예를 들어 우리가 어디에 서류를 제출하는 것은 우리에 대한 정보를 제출하여(POST) 추가하기 위함입니다.

이러한 상황과 유사하게 POST 방식은 데이터를 서버로 제출하여 **추가 또는 수정하기 위해서 사용하는 방식**입니다.

### **[ POST방식의 특징 ]**

- URL에 변수(데이터)를 노출하지 않고 요청한다.
- 데이터를 Body(바디)에 포함시킨다.
- URL에 데이터가 노출되지 않아 기본 보안이 되어있다.
- 데이터 길이에 제한이 없다.
- 캐싱할 수 없다.

GET방식은 URL에 데이터를 붙여서 전송하는 반면에 POST방식은 BODY에 데이터를 넣어서 전송합니다.

따라서 헤더필드 중 Body에 포함시키는 이점 때문에 메시지 길이의 제한은 없지만 최대 요청을 받는 시간인 Time Out이 존재하므로 클라이언트에서 페이지를 요청하고 기다리는 시간이 존재합니다.

실제로 상황에서 POST 방식은 URL에 데이터가 노출되지 않으므로 즐겨찾기나 캐싱이 불가능하지만 쿼리스트링(문자열)데이터 뿐만 아니라, 라디오 버튼, 텍스트 박스와 같은 객체들의 값도 전송이 가능합니다.

**GET 방식**

- 중요 개념 : GET은 '가져오는 것'
- DB로 따지면 GET은 SELECT에 가깝다.
- ex) 데이터를 가져와서 봄. (게시판의 리스트, 글보기 등)
- GET 요청은 멱등이다.

**POST 방식**

- 중요 개념 : POST는 '수행하는 것'
- DB로 따지면 POST는 CREATE에 가깝다.
- ex) 서버의 값이나 상태를 바꿈. (게시판의 글쓰기, 수정)
- POST는 멱등이 아니다.

> 멱등이란?멱등의 사전적 정의는 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미합니다. GET은 리소스를 조회한다는 점에서 여러 번 요청하더라도 응답이 똑같을 것이고, 반대로 POST는 리소스를 새로 생성하거나 업데이트할 때 사용되기 때문에 멱등이 아니라고 볼 수 있습니다.
> 

GET과 POST는 이런 차이들이 있기 때문에 사용하려는 목적에 맞게 사용해야 합니다.

### POST방식이 GET방식보다 보안측면에서 더 좋다?

GET과 비교하여 URL에 데이터의 정보가 들어 있지 않으므로 조금 더 안전하다고 볼 수 있다.

### GET방식이 POST방식보다 속도가 빠르다?

GET 방식은 캐싱을 하기 때문에 여러번 요청시 저장된 데이터를 활용하므로 조금 더 빠를 수 있다.

### POST vs PUT

POST와 PUT은 구분해서 사용해야한다. POST는 새로운 데이터를 계속 생성하기 때문에 요청시마다 데이터를 생성하지만, PUT은 사용자가 데이터를 지정하고 수정하는 것이기 때문에 같은 요청을 계속하더라도 데이터가 계속 생성되지는 않는다.

### PUT vs PATCH

PUT은 지정한 데이터를 전부 수정하는 Method이지만 PATCH는 정보의 일부분이 변경되는 방법이다. 그래서 PUT은 멱등하지만, PATCH는 멱등하다고 볼 수 없습니다.

---

### 질문2. **GET과 POST의 차이에 대해 설명해주세요.**

**질문 답변**

**GET**은 데이터를 조회하기 위해 사용되는 방식으로 데이터를 헤더에 추가하여 전송하는 방식입니다. URL에 데이터가 노출되므로 보안적으로 중요한 데이터를 포함해서는 안됩니다. 

**POST**는 데이터를 추가 또는 수정하기 위해 사용되는 방식으로 데이터를 바디에 추가하여 전송하는 방식입니다.

완전히 안전하다는 것은 아니지만 URL에 데이터가 노출되지 않아 GET 보다는 안전합니다.

| 처리 방식 | GET 방식 | POST 방식 |
| --- | --- | --- |
| URL에 데이터 노출 여부 | O | X |
| 데이터의 위치 | Header(헤더) | Body(바디) |
| 캐싱 가능 여부 | O | X |
| 멱등성 여부 | O | X |
