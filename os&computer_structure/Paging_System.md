# 페이징 시스템(Paging System)

### 2. 페이징 시스템의 장점에 대해 설명하시오

> 페이징 시스템은 가상 메모리를 사용하기 때문에, 프로세스가 필요한 메모리 크기가 실제 물리적인 메모리 크기보다 크더라도 실행이 가능합니다. 이를 통해 메모리 사용 효율을 높일 수 있습니다. 또한, 페이징 시스템은 페이지 교체 알고리즘을 사용하여, 메모리에 공간이 부족한 경우 페이지를 교체하여 새로운 페이지를 메모리에 올릴 수 있습니다.
> 

- 페이징 시스템
    - 고정 분할 방식으로 메모리를 분할한 가상 메모리 관리 기법
    - 크기가 동일한 page로 가상 주소 공간과 이에 매핑되는 물리 주소 공간을 관리
        - page: 고정된 동일한 크기의 블록
    
    ![paging_system](https://user-images.githubusercontent.com/88701965/231023458-805173fc-5ef7-4cb0-b9fc-dc0aff88defb.png)

    
    - page table
        - 가상 주소와 물리 주소간 매핑 정보를 담고 있다
        - 가상 주소의 각 페이지가 물리 메모리의 어디에 위치하는 지를 나타낸다
        - 페이지와 프레임은 크기가 같기 때문에 어떤 프레임에도 배치될 수 있다
    - 페이징 시스템 동작 과정
        
        > 첫째, 프로세스 실행 시 필요한 페이지를 메모리에 로드한다. 이때, 로드되는 페이지는 해당 페이지에 대한 접근이 발생하면 물리적인 메모리 주소와 매핑된다.
        둘째, 프로세스에서 페이지에 접근할 때마다, 페이징 시스템은 해당 페이지의 물리적인 메모리 주소를 찾아서 접근할 수 있도록 해준다.
        > 
        
        > **p** : 가상 메모리의 page 번호
        **d** : p안에서 참조하는 위치(페이지 내부 주소; offset)
        > 
        1. page table에 해당 가상 주소와 그 page 번호(p)가 있는지 확인한다.
        2. page 번호가 있으면 이와 매핑된 첫 물리 주소(p')를 알아낸다
        3. 그러면 페이지 처음부터 얼마 떨어진 위치인지를 알려주는 변위(d)를 더하면
        4. p' + d 가 실제 물리 주소가 된다.
    
    - TLB(Translation Lookingside Buffer)
        
        MMU를 좀 더 효율적으로 동작시키는 방법
        
        최근 물리 주소로 변환된 가상 주소 정보를 저장하여 페이지 정보를 캐쉬할 수 있는 하드웨어
        
        ![TLB1](https://user-images.githubusercontent.com/88701965/231023461-c2b5b7b3-9af5-4705-b96c-5fe0c81e3b11.png)

        
- Demand Paging
    
    페이징 시스템을 사용하면 프로세스에서 나눠진 page를 언제 물리 메모리에 올려놓을지에 대한 정책이 필요 → 실제로 필요할 때 page를 메모리에 올리는 것이 중요 !!
    
    <aside>
    💡 프로세스의 모든 데이터를 메모리로 적재하지 않고
    실행 중 필요한 시점에서만 메모리로 적재
    
    </aside>
    
    - **page fault**
        
        어떤 페이지가 물리 메모리에 없을 때 발생하는 인터럽트로
        
        page fault가 발생하면 운영체제가 해당 페이지를 물리 메모리에 올려준다.
        
        - invalid bit
            
            사용되지 않는 주소 영역으로 페이지가 물리적 메모리에 없는 경우 → page fault
            
            처음에는 모든 페이지가 invalid로 초기화
            
    
    ![TLB2](https://user-images.githubusercontent.com/88701965/231023465-4b5321e5-def0-40ef-b64c-c582310d2a26.png)

    
    1. CPU가 페이지 참조
    2. 페이지 테이블을 보니 페이지 상태가 "무효" 상태
    3. MMU에서 페이지 폴트 트랩을 발생
    4. 디스크에서 메모리로 페이지를 가져온 후 "유효" 상태로 변경
    
    - **페이지 폴트 발생 후 메모리로 페이지를 가져오려는 데 메모리가 부족한 경우**
        
        페이지 교체 정책 사용
        
        페이지 부재 발생 → 새로운 페이지를 할당해야 함 → 현재 할당된 페이지 중 어떤 것 교체할 지 결정하는 방법
        
- 참고자료
    
    [OS는 할껀데 핵심만 합니다. 14편 가상 메모리 개요, 페이징](https://velog.io/@chappi/OS는-할껀데-핵심만-합니다.-14편-가상-메모리-개요-페이징)
    
    [# 다중 단계 페이징](https://velog.io/@choiish98/다중-단계-페이징)
    
    [[OS] 운영체제 질문 - (프로세스,스레드,동기화 문제,교착상태,페이징,가상메모리)](https://onejunu.tistory.com/159)